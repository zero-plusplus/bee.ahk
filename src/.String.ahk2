class String extends bee.rule.Primitive {
  /**
   * Returns the number of times the specified `pattern` is matched.
   * @param {string} str
   * @param {string | bee.PatternLiteral} pattern
   * @return {number}
   */
  static count(str, pattern) {
    pattern := bee.PatternLiteral(pattern)
    if (pattern.type == "regex") {
      RegExReplace(str, bee.RegEx.fromRegExLiteral(pattern).value, "", &count)
      return count
    }
    caseSensitive := pattern.type == "ignorecase" ? false : true
    StrReplace(str, pattern.text, "", caseSensitive, &count)
    return count
  }
  /**
   * Returns the number of times the specified `pattern` is matched.
   * @param {string | bee.PatternLiteral} pattern
   * @return {number}
   */
  count(pattern) {
    return bee.String.count(this.value, pattern)
  }
  static format(str, params*) {
    return Format(str, params*)
  }
  /**
   * @param {string} str
   * @param {string | { text: string, type: "text" } | { text: string, type: "ignorecase" }} str
   * @param {string | (pattern: string, offset: number, str: string) => string} replacement - A string to replace or a callable object to output it
   * @param {number} [limit := -1]
   * @return {string}
   */
  /**
   * @param {string} str
   * @param {string<regex> | { text: string, type: "regex" }} pattern
   * @param {string | (match: RegExMatchInfo, pattern: string) => string} replacement - A string to replace or a callable object to output it
   * @param {number} [limit := -1]
   * @return {string}
   */
  static replace(str, pattern, replacement, limit := -1) {
    pattern := bee.PatternLiteral(pattern)
    if (pattern.type == "regex") {
      return bee.RegEx.fromRegExLiteral(pattern).replace(str, replacement, limit)
    }

    caseSensitive := pattern.type == "ignorecase" ? false : true
    if (!bee.isCallable(replacement)) {
      return StrReplace(str, pattern.text, replacement, caseSensitive, , limit)
    }

    replaced := str
    callback := bee.callback(replacement)
    count := 1
    while (true) {
      if (-1 < limit && limit < count) {
        break
      }
      offset := InStr(replaced, pattern.text, caseSensitive)
      if (offset == 0) {
        break
      }
      replacement := callback(pattern.text, offset, replaced)
      replaced := StrReplace(replaced, pattern.text, replacement, caseSensitive, , 1)
      count++
    }
    return replaced
  }
  /**
   * @param {string | { text: string, type: "text" } | { text: string, type: "ignorecase" }} str
   * @param {string | (pattern: string, offset: number, str: string) => string} replacement - A string to replace or a callable object to output it
   * @param {number} [limit := -1]
   * @return {string}
   */
  /**
   * @param {string<regex> | { text: string, type: "regex" }} pattern
   * @param {string | (match: RegExMatchInfo, pattern: string) => string} replacement - A string to replace or a callable object to output it
   * @param {number} [limit := -1]
   * @return {string}
   */
  replace(pattern, replacement, limit := -1) {
    replaced := bee.String.replace(this.value, pattern, replacement, limit)
    return bee.String(replaced)
  }
  /**
   * @param {string} str
   * @param {string | { text: string, type: "text" } | { text: string, type: "ignorecase" }} str
   * @param {string | (pattern: string, offset: number, str: string) => string} replacement - A string to replace or a callable object to output it
   * @return {string}
   */
  /**
   * @param {string} str
   * @param {string<regex> | { text: string, type: "regex" }} pattern
   * @param {string | (match: RegExMatchInfo, pattern: string) => string} replacement - A string to replace or a callable object to output it
   * @return {string}
   */
  static replaceAll(str, pattern, replacement) {
    return bee.String.replace(str, pattern, replacement, -1)
  }
  /**
   * @param {string | { text: string, type: "text" } | { text: string, type: "ignorecase" }} str
   * @param {string | (pattern: string, offset: number, str: string) => string} replacement - A string to replace or a callable object to output it
   * @return {string}
   */
  /**
   * @param {string<regex> | { text: string, type: "regex" }} pattern
   * @param {string | (match: RegExMatchInfo, pattern: string) => string} replacement - A string to replace or a callable object to output it
   * @return {string}
   */
  replaceAll(pattern, replacement) {
    replaced := bee.String.replaceAll(this.value, pattern, replacement)
    return bee.String(replaced)
  }
  /**
   * @param {string} str
   * @param {string | { text: string, type: "text" } | { text: string, type: "ignorecase" }} str
   * @param {string | (pattern: string, offset: number, str: string) => string} replacement - A string to replace or a callable object to output it
   * @return {string}
   */
  /**
   * @param {string} str
   * @param {string<regex> | { text: string, type: "regex" }} pattern
   * @param {string | (match: RegExMatchInfo, pattern: string) => string} replacement - A string to replace or a callable object to output it
   * @return {string}
   */
  static replaceFirst(str, pattern, replacement) {
    return bee.String.replace(str, pattern, replacement, 1)
  }
  /**
   * @param {string | { text: string, type: "text" } | { text: string, type: "ignorecase" }} str
   * @param {string | (pattern: string, offset: number, str: string) => string} replacement - A string to replace or a callable object to output it
   * @return {string}
   */
  /**
   * @param {string<regex> | { text: string, type: "regex" }} pattern
   * @param {string | (match: RegExMatchInfo, pattern: string) => string} replacement - A string to replace or a callable object to output it
   * @return {string}
   */
  replaceFirst(pattern, replacement) {
    replaced := bee.String.replaceFirst(this.value, pattern, replacement)
    return bee.String(replaced)
  }
  /**
   * Returns a new string with the specified range of the string sliced.
   * @param {string} str
   * @param {Parameters<bee.RangeLiteral>} rangeLiteralParams
   * @return {string}
   */
  static slice(str, rangeLiteralParams*) {
    range := bee.RangeLiteral(rangeLiteralParams*)
    str_len := this.length(str)
    start := range.start.reverse ? str_len - (range.start.index - 1) : range.start.index
    end := (range.end.reverse ? str_len - (range.end.index - 1) : range.end.index) - range.excludeEnd

    sliced := SubStr(str, start, end - (start - 1))
    return sliced
  }
  /**
   * Returns a new string with the specified range of the string sliced.
   * @param {Parameters<bee.RangeLiteral>} rangeLiteralParams
   * @return {string}
   */
  slice(rangeLiteralParams*) {
    sliced := bee.String.slice(this.value, rangeLiteralParams*)
    return bee.String(sliced)
  }
  /**
   * Embeds the value of a variable in a string.
   *
   * You can determine the value to embed in the format `${key_or_index}` as shown in the following example.
   * ```ahk2
   * bee.String.template("${key}", { key: "value" }) ; => "value"
   * ```
   *
   * If you want to get nested properties, connect them with dots.
   * ```ahk2
   * bee.String.template("${key.nest}", { key: { nest: "value" } }) ; => "value"
   * ```
   *
   * If you pass an array to `variable`, specify a index.
   * ```ahk2
   * bee.String.template("${1}, ${2.nest}", [ "value", { nest: "value2" }]) ;=> "value, value2"
   * ```
   *
   * If you omit the index, the index will be incremented by the number of repetitions.
   * ```ahk2
   * bee.String.template("${}, ${}, ${}", [ 1, 2, 3 ]) ;=> "1, 2, 3"
   * ```
   *
   * If you do not want to embed the value, prefix the `$` with `\`.
   * ```ahk2
   * bee.String.template("\${1}, ${1}", "value") ;=> "${1}, value"
   * ```
   *
   * If you pass `variable` followed by an argument, it will have the same meaning as if you had passed an array.
   * In other words, the following will be the same.
   * ```ahk
   * bee.String.template("${}, ${}, ${}", [ "a", "b", "c" ]) ;=> "a, b, c"
   * bee.String.template("\${1}, ${1}", "a", "b", "c") ;=> "a, b, c"
   * ```
   * @param {string} str
   * @param {any} variable
   * @param {any[]} variables*
   * @return {string}
   */
  static template(str, variables*) {
    source := variables.length == 1 ? variables[1] : variables
    if (bee.isPrimitive(source)) {
      source := [ source ]
    }

    formatted := bee.String.replaceAll(str, "/(?<!\\)\$\{(?<key>[^\s\{\}]*)?\}/i", Template.bind({ source: source, count: 1 }))
    formatted := bee.String.replaceAll(formatted, "/\\(\$\{[^\s\{\}]*\})/i", "$1")
    return formatted

    Template(context, match, str, *) {
      if (bee.toNumber(match.key) == 0) {
        value := context.source
      }
      else {
        keys := StrSplit(match.key ? match.key : context.count, ".")
        if (bee.hasNestedKey(context.source, keys*)) {
          value := bee.getNestedProp(context.source, keys*)
        }
      }
      context.count++
      if (!IsSet(value)) {
        return match[0]
      }
      if (bee.isPrimitive(value)) {
        return value
      }
      return bee.Json.stringify(value, { space: true })
    }
  }
  /**
   * Embeds the value of a variable in a string.
   *
   * You can determine the value to embed in the format `${key_or_index}` as shown in the following example.
   * ```ahk2
   * bee.String.template("${key}", { key: "value" }) ; => "value"
   * ```
   *
   * If you want to get nested properties, connect them with dots.
   * ```ahk2
   * bee.String.template("${key.nest}", { key: { nest: "value" } }) ; => "value"
   * ```
   *
   * If you pass an array to `variable`, specify a index.
   * ```ahk2
   * bee.String.template("${1}, ${2.nest}", [ "value", { nest: "value2" }]) ;=> "value, value2"
   * ```
   *
   * If you omit the index, the index will be incremented by the number of repetitions.
   * ```ahk2
   * bee.String.template("${}, ${}, ${}", [ 1, 2, 3 ]) ;=> "1, 2, 3"
   * ```
   *
   * If you do not want to embed the value, prefix the `$` with `\`.
   * ```ahk2
   * bee.String.template("\${1}, ${1}", "value") ;=> "${1}, value"
   * ```
   *
   * If you pass `variable` followed by an argument, it will have the same meaning as if you had passed an array.
   * In other words, the following will be the same.
   * ```ahk
   * bee.String.template("${}, ${}, ${}", [ "a", "b", "c" ]) ;=> "a, b, c"
   * bee.String.template("\${1}, ${1}", "a", "b", "c") ;=> "a, b, c"
   * ```
   * @param {any} variable
   * @param {any[]} variables*
   * @return {bee.String}
   */
  template(variables*) {
    templated := bee.String.template(this.value, variables*)
    return bee.String(templated)
  }
}