class String extends bee.rule.Primitive {
  /**
   * Returns the number of times the specified `pattern` is matched.
   * @param {string} str
   * @param {string | bee.PatternLiteral} pattern
   * @return {number}
   */
  static count(str, pattern) {
    pattern := bee.PatternLiteral(pattern)
    if (pattern.type == "regex") {
      RegExReplace(str, bee.RegEx.fromRegExLiteral(pattern).value, "", &count)
      return count
    }
    caseSensitive := pattern.type == "ignorecase" ? false : true
    StrReplace(str, pattern.text, "", caseSensitive, &count)
    return count
  }
  /**
   * Returns the number of times the specified `pattern` is matched.
   * @param {string | bee.PatternLiteral} pattern
   * @return {number}
   */
  count(pattern) {
    return bee.String.count(this.value, pattern)
  }
  /**
   * @param {string} str
   * @param {string | { text: string, type: "text" } | { text: string, type: "ignorecase" }} str
   * @param {string | (pattern: string, offset: number, str: string) => string} replacement - A string to replace or a callable object to output it
   * @param {number} [limit := -1]
   * @return {string}
   */
  /**
   * @param {string} str
   * @param {string<regex> | { text: string, type: "regex" }} pattern
   * @param {string | (match: RegExMatchInfo, pattern: string) => string} replacement - A string to replace or a callable object to output it
   * @param {number} [limit := -1]
   * @return {string}
   */
  static replace(str, pattern, replacement, limit := -1) {
    pattern := bee.PatternLiteral(pattern)
    if (pattern.type == "regex") {
      return bee.RegEx.fromRegExLiteral(pattern).replace(str, replacement, limit)
    }

    caseSensitive := pattern.type == "ignorecase" ? false : true
    if (!bee.isCallable(replacement)) {
      return StrReplace(str, pattern.text, replacement, caseSensitive, , limit)
    }

    replaced := str
    callback := bee.callback(replacement)
    count := 1
    while (true) {
      if (-1 < limit && limit < count) {
        break
      }
      offset := InStr(replaced, pattern.text, caseSensitive)
      if (offset == 0) {
        break
      }
      replacement := callback(pattern.text, offset, replaced)
      replaced := StrReplace(replaced, pattern.text, replacement, caseSensitive, , 1)
      count++
    }
    return replaced
  }
  /**
   * @param {string | { text: string, type: "text" } | { text: string, type: "ignorecase" }} str
   * @param {string | (pattern: string, offset: number, str: string) => string} replacement - A string to replace or a callable object to output it
   * @param {number} [limit := -1]
   * @return {string}
   */
  /**
   * @param {string<regex> | { text: string, type: "regex" }} pattern
   * @param {string | (match: RegExMatchInfo, pattern: string) => string} replacement - A string to replace or a callable object to output it
   * @param {number} [limit := -1]
   * @return {string}
   */
  replace(pattern, replacement, limit := -1) {
    replaced := bee.String.replace(this.value, pattern, replacement, limit)
    return bee.String(replaced)
  }
  /**
   * @param {string} str
   * @param {string | { text: string, type: "text" } | { text: string, type: "ignorecase" }} str
   * @param {string | (pattern: string, offset: number, str: string) => string} replacement - A string to replace or a callable object to output it
   * @return {string}
   */
  /**
   * @param {string} str
   * @param {string<regex> | { text: string, type: "regex" }} pattern
   * @param {string | (match: RegExMatchInfo, pattern: string) => string} replacement - A string to replace or a callable object to output it
   * @return {string}
   */
  static replaceAll(str, pattern, replacement) {
    return bee.String.replace(str, pattern, replacement, -1)
  }
  /**
   * @param {string | { text: string, type: "text" } | { text: string, type: "ignorecase" }} str
   * @param {string | (pattern: string, offset: number, str: string) => string} replacement - A string to replace or a callable object to output it
   * @return {string}
   */
  /**
   * @param {string<regex> | { text: string, type: "regex" }} pattern
   * @param {string | (match: RegExMatchInfo, pattern: string) => string} replacement - A string to replace or a callable object to output it
   * @return {string}
   */
  replaceAll(pattern, replacement) {
    replaced := bee.String.replaceAll(this.value, pattern, replacement)
    return bee.String(replaced)
  }
  /**
   * @param {string} str
   * @param {string | { text: string, type: "text" } | { text: string, type: "ignorecase" }} str
   * @param {string | (pattern: string, offset: number, str: string) => string} replacement - A string to replace or a callable object to output it
   * @return {string}
   */
  /**
   * @param {string} str
   * @param {string<regex> | { text: string, type: "regex" }} pattern
   * @param {string | (match: RegExMatchInfo, pattern: string) => string} replacement - A string to replace or a callable object to output it
   * @return {string}
   */
  static replaceFirst(str, pattern, replacement) {
    return bee.String.replace(str, pattern, replacement, 1)
  }
  /**
   * @param {string | { text: string, type: "text" } | { text: string, type: "ignorecase" }} str
   * @param {string | (pattern: string, offset: number, str: string) => string} replacement - A string to replace or a callable object to output it
   * @return {string}
   */
  /**
   * @param {string<regex> | { text: string, type: "regex" }} pattern
   * @param {string | (match: RegExMatchInfo, pattern: string) => string} replacement - A string to replace or a callable object to output it
   * @return {string}
   */
  replaceFirst(pattern, replacement) {
    replaced := bee.String.replaceFirst(this.value, pattern, replacement)
    return bee.String(replaced)
  }
  /**
   * Returns a new string with the specified range of the string sliced.
   * @param {string} str
   * @param {Parameters<bee.RangeLiteral>} rangeLiteralParams
   * @return {string}
   */
  static slice(str, rangeLiteralParams*) {
    range := bee.RangeLiteral(rangeLiteralParams*)
    str_len := this.length(str)
    start := range.start.reverse ? str_len - (range.start.index - 1) : range.start.index
    end := (range.end.reverse ? str_len - (range.end.index - 1) : range.end.index) - range.excludeEnd

    sliced := SubStr(str, start, end - (start - 1))
    return sliced
  }
  /**
   * Returns a new string with the specified range of the string sliced.
   * @param {Parameters<bee.RangeLiteral>} rangeLiteralParams
   * @return {string}
   */
  slice(rangeLiteralParams*) {
    sliced := bee.String.slice(this.value, rangeLiteralParams*)
    return bee.String(sliced)
  }
}