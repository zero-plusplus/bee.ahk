class Enumerable {
  ;; @type {object}
  source := ""
  /**
   * @template KEY, VALUE
   * @param {object<KEY, VALUE>} source
   * @return {bee.Enumerable<object<KEY, VALUE>}
   */
  __New(source) {
    this.source := source
  }
  __Enum(*) {
    return this.toEnumeratorLike()
  }
  /**
   * Converts a string to a bee.Enumerable that enumerates each character.
   * @method
   * @return {bee.Enumerable<object<number, string>}
   */
  class chars extends bee.rule.EnumerableFunc {
    _init() {
      this.source := bee.isString(this.source) ? this.source : ""
      this.current := 1
    }
    _next(&key, &value := unset) {
      if (StrLen(this.source) < this.current) {
        return false
      }

      key := this.current
      value := SubStr(this.source, this.current, 1)
      this.current++
      return true
    }
  }
  /**
   * Sets a default fields for the `data`.
   * @template KEY, VALUE
   * @method
   * @param {object<KEY, VALUE>} source
   * @param {object<KEY, VALUE>[]} defaultSources*
   * @return {bee.Enumerable<KEY, VALUE>}
   */
  class defaults extends bee.rule.EnumerableFunc {
    _init() {
      this.defaultSources := this.args
      this.current := this.defaultSources.length
      this.defaultSourceEnumerator := bee.Enumerable.toEnumeratorLike(bee.tryGetProp(this.defaultSources, this.current, {}))
      this.keys := []
    }
    _next(&key, &value := unset) {
      hasNext := this.enumerator.call(&_key, &_value)
      if (hasNext) {
        key := _key
        value := _value
        this.keys.push(key)
        return true
      }

      while (this.defaultSourceEnumerator.call(&_key, &_value)) {
        if (bee.any.equals(this.keys, _key)) {
          continue
        }

        key := _key
        value := _value
        this.keys.push(key)
        return true
      }
      this.current--

      if (!bee.hasKey(this.defaultSources, this.current)) {
        return false
      }
      this.defaultSourceEnumerator := bee.Enumerable.toEnumeratorLike(this.defaultSources[this.current])
      this._next(&key, &value)
    }
  }
  /**
   * Sets a default fields for the `data`.
   * @method
   * @param {object<KEY, VALUE>[]} defaultSources*
   * @return {bee.Enumerable<KEY, VALUE>}
   */
  defaults(defaultSources*) {
    return bee.Enumerable.defaults(this, defaultSources*)
  }
  /**
   * Replace the value with the value returned by the specified `selector`.
   * @template KEY, VALUE, TRemapValue
   * @param {object<KEY, VALUE>} source
   * @param {() => TRemapValue} selector
   * @return {bee.Enumerable<KEY, TRemapValue>}
   */
  class select extends bee.rule.EnumerableFunc {
    _init() {
      this.selector := bee.callback(this.args[1])
    }
    _next(&key, &value) {
      if (!this.enumerator.call(&_key, &_value)){
        return false
      }
      key := _key
      value := this.selector.call(_key, _value)
      return true
    }
  }
  /**
   * Replace the value with the value returned by the specified `selector`.
   * @param {() => TRemapValue} selector
   * @return {bee.Enumerable<KEY, TRemapValue>}
   */
  select(selector) {
    return bee.Enumerable.select(this, selector)
  }
  /**
   * Convert to an `Array` of objects with key and value fields.
   * @template KEY, VALUE
   * @param {object<KEY, VALUE>} source
   * @return {bee.Enumerable<KEY, VALUE>}
   */
  class toArray extends bee.rule.EnumerableConverter {
    static behavior(enumerator) {
      arr := []
      for key, value in enumerator {
        arr.push({ key: key, value: value })
      }
      return arr
    }
  }
  /**
   * Convert to an `Array` of objects with key and value fields.
   * @return
   */
  toArray() {
    return bee.Enumerable.toArray(this)
  }
  /**
   * Converts `source` to an `Array` of keys.
   * @method
   * @param {bee.Enumerable}
   * @return {Array<KEY>}
   */
  class toKeys extends bee.rule.EnumerableConverter {
    static behavior(enumerator) {
      arr := []
      for key, value in enumerator {
        arr.push(key)
      }
      return arr
    }
  }
  /**
   * Converts to an `Array` of keys.
   */
  toKeys() {
    return bee.Enumerable.toKeys(this)
  }
  /**
   * Convert to `Map`.
   * @template KEY, VALUE
   * @param {object<KEY, VALUE>} source
   * @return {Map<KEY, VALUE>}
   */
  class toMap extends bee.rule.EnumerableConverter {
    static behavior(enumerator) {
      _map := Map()
      for key, value in enumerator {
        _map[key] := value
      }
      return _map
    }
  }
  /**
   * Convert to `Map`.
   * @return {Map<KEY, VALUE>}
   */
  toMap() {
    return bee.Enumerable.toMap(this)
  }
  /**
   * Convert to `Object`.
   * @param {object<KEY, VALUE>} source
   * @return {Object<KEY, VALUE>}
   */
  class toObject extends bee.rule.EnumerableConverter {
    static behavior(enumerator) {
      obj := {}
      for key, value in enumerator {
        obj.%key% := value
      }
      return obj
    }
  }
  /**
   * Convert to `Object`.
   * @return {Object<KEY, VALUE>}
   */
  toObject() {
    return bee.Enumerable.toObject(this)
  }
  /**
   * Converts `source` to an `Array` of values.
   * @method
   * @param {bee.Enumerable}
   * @return {Array<VALUE>}
   */
  class toValues extends bee.rule.EnumerableConverter {
    static behavior(enumerator) {
      arr := []
      for key, value in enumerator {
        arr.push(value)
      }
      return arr
    }
  }
  /**
   * Convert to an `Array` of values.
   */
  toValues() {
    return bee.Enumerable.toValues(this)
  }
  /**
   * Returns all elements for which the `predicate` returns `true`.
   * @method
   * @param {any} value
   * @param {(value, key, enumerable) => boolean} predicate
   */
  class where extends bee.rule.EnumerableFunc {
    _init() {
      this.predicate := bee.callback(this.args[1])
    }
    _next(&key, &value) {
      while (this.enumerator.call(&_key, &_value)) {
        if (this.predicate.call(_key, _value)) {
          key := _key
          value := _value
          return true
        }
      }
      return false
    }
  }
  /**
   * Returns all elements for which the `predicate` returns `true`.
   * @param {(key, value) => boolean} predicate
   * @return {bee.Enumerable<KEY, VALUE}
   */
  where(predicate) {
    return bee.Enumerable.where(this, predicate)
  }
  /**
   * `Array` and `Map` are converted to Enumerator, and the rest to improved Enumerator-like function.
   *
   * **Note that this means that using the `is` operator does not always return `true`, such as follows.*
   * @template KEY, VALUE
   * @param {object<KEY, VALUE.} source
   * @return {Enumerator | (&key: KEY, &value?: VALUE) => boolean}
   */
  static toEnumeratorLike(source) {
    if (source is Enumerator) {
      return source
    }

    if (source is bee.Enumerable) {
      if (bee.isPrimitive(source.source)) {
        return source
      }
      if (source.source is bee.Enumerable) {
        return source.source.__Enum(2)
      }
      return this.toEnumeratorLike(source.source)
    }
    if (source is Array || source is Map) {
      return source.__Enum(2)
    }
    return EnumeratorWrapper.bind(source, source.ownProps())

    EnumeratorWrapper(obj, enumerator, &key, &value) {
      hasNext := enumerator(&_key)
      if (!hasNext) {
        return false
      }
      key := _key
      value := obj.%key%
      return true
    }
  }
  /**
   * `Array` and `Map` are converted to Enumerator, and the rest to improved Enumerator-like function.
   *
   * **Note that this means that using the `is` operator does not always return `true`, such as follows.**
   * @return {Enumerator | (&key: KEY, &value?: VALUE) => boolean}
   */
  toEnumeratorLike() {
    return bee.Enumerable.toEnumeratorLike(this)
  }
}