class Enumerable {
  ;; @type {object}
  source := ""
  /**
   * @template KEY, VALUE
   * @param {primitive | object<KEY, VALUE>} source - If a primitive value is specified, it will be wrapped in an array.
   * @return {bee.Enumerable<object<KEY, VALUE>}
   */
  __New(source) {
    this.source := bee.isPrimitive(source) ? [ source ] : source
  }
  __Enum(*) {
    return this.toEnumeratorLike()
  }
; #region Building
  /**
   * Converts a string to a bee.Enumerable that enumerates each character.
   * @method
   * @return {bee.Enumerable<object<number, string>}
   */
  class chars extends bee.rule.EnumerableFunc {
    __New(source) {
      this.source := bee.isString(source) ? source : ""
    }
    _init() {
      this.current := 1
    }
    _next(&key, &value := unset) {
      if (StrLen(this.source) < this.current) {
        return false
      }

      key := this.current
      value := SubStr(this.source, this.current, 1)
      this.current++
      return true
    }
  }
  /**
   * Builds a `bee.Enumerable` that enumerates the specified range.
   * @method
   * @param {Parameters<bee.RangeLiteral.__New>} rangeLiteralParams*
   * @return {bee.Enumerable<object<number, number>}
   */
  class range extends bee.rule.EnumerableFunc {
    __New(params*) {
      this.range := bee.RangeLiteral(params*)
    }
    _init() {
      this.increment := 1
      this.current := 1
      this.start := this.range.start.index
      this.end := (this.range.end.index - (this.start - 1)) - this.range.excludeEnd
      this.step := this.range.step
      this.unicodeMode := this.range.unicodeMode
    }
    _next(&key, &value) {
      if (this.end < this.current) {
        return false
      }
      key := this.increment

      _value := this.start + (this.current - 1)
      value := this.unicodeMode ? Chr(_value) : _value

      this.increment++
      this.current += this.step
      return true
    }
  }
; #endregion Building
; #region Projection
  /**
   * Concatenate the current sequence with one or more additional sequences.
   * @template KEY, VALUE
   * @param {object<KEY, VALUE>} source
   * @param {Array<object<KEY, VALUE>>} additionalSources*
   * @return {bee.Enumerable<object<KEY, VALUE>>}
   */
  class concat extends bee.rule.EnumerableFunc {
    _init() {
      this.current := 1
      this.additionalSources := this.args
      this.additonalSequence := bee.Enumerable.toEnumeratorLike(this.additionalSources[this.current])
    }
    _next(&key, &value := unset) {
      if (this.enumerator.call(&key, &value)) {
        return true
      }
      if (this.additonalSequence.call(&key, &value)) {
        return true
      }

      this.current++
      if (!bee.hasKey(this.additionalSources, this.current)) {
        return false
      }

      this.additonalSequence := bee.Enumerable.toEnumeratorLike(this.additionalSources[this.current])
      return this._next(&key, &value)
    }
  }
  /**
   * Concatenate the current sequence with one or more additional sequences.
   * @param {Array<object<KEY, VALUE>>} additionalSources*
   * @return {bee.Enumerable<object<KEY, VALUE>>}
   */
  concat(additionalSources*) {
    return bee.Enumerable.concat(this, additionalSources*)
  }
  /**
   * Sets a default fields for the `data`.
   * @template KEY, VALUE
   * @method
   * @param {object<KEY, VALUE>} source
   * @param {object<KEY, VALUE>[]} defaultSources*
   * @return {bee.Enumerable<KEY, VALUE>}
   */
  class defaults extends bee.rule.EnumerableFunc {
    _init() {
      this.defaultSources := this.args
      this.current := this.defaultSources.length
      this.defaultSourceEnumerator := bee.Enumerable.toEnumeratorLike(bee.tryGetProp(this.defaultSources, this.current, {}))
      this.keys := []
    }
    _next(&key, &value := unset) {
      hasNext := this.enumerator.call(&_key, &_value)
      if (hasNext) {
        key := _key
        value := _value
        this.keys.push(key)
        return true
      }

      while (this.defaultSourceEnumerator.call(&_key, &_value)) {
        if (bee.any.equals(this.keys, _key)) {
          continue
        }

        key := _key
        value := _value
        this.keys.push(key)
        return true
      }
      this.current--

      if (!bee.hasKey(this.defaultSources, this.current)) {
        return false
      }
      this.defaultSourceEnumerator := bee.Enumerable.toEnumeratorLike(this.defaultSources[this.current])
      return this._next(&key, &value)
    }
  }
  /**
   * Sets a default fields for the `data`.
   * @method
   * @param {object<KEY, VALUE>[]} defaultSources*
   * @return {bee.Enumerable<KEY, VALUE>}
   */
  defaults(defaultSources*) {
    return bee.Enumerable.defaults(this, defaultSources*)
  }
  /**
   * Replace the value with the value returned by the specified `selector`.
   * @template KEY, VALUE, TRemapValue
   * @param {object<KEY, VALUE>} source
   * @param {() => TRemapValue} selector
   * @return {bee.Enumerable<KEY, TRemapValue>}
   */
  class select extends bee.rule.EnumerableFunc {
    _init() {
      this.selector := bee.callback(this.args[1])
    }
    _next(&key, &value) {
      if (!this.enumerator.call(&_key, &_value)){
        return false
      }
      key := _key
      value := this.selector.call(_key, _value)
      return true
    }
  }
  /**
   * Replace the value with the value returned by the specified `selector`.
   * @param {() => TRemapValue} selector
   * @return {bee.Enumerable<KEY, TRemapValue>}
   */
  select(selector) {
    return bee.Enumerable.select(this, selector)
  }
; #endregion Projection
; #region Filtering
  /**
   * Returns all elements for which the `predicate` returns `true`.
   * @method
   * @param {any} value
   * @param {(value, key, enumerable) => boolean} predicate
   */
  class where extends bee.rule.EnumerableFunc {
    _init() {
      this.predicate := bee.callback(this.args[1])
    }
    _next(&key, &value) {
      while (this.enumerator.call(&_key, &_value)) {
        if (this.predicate.call(_key, _value)) {
          key := _key
          value := _value
          return true
        }
      }
      return false
    }
  }
  /**
   * Returns all elements for which the `predicate` returns `true`.
   * @param {(key, value) => boolean} predicate
   * @return {bee.Enumerable<KEY, VALUE}
   */
  where(predicate) {
    return bee.Enumerable.where(this, predicate)
  }
; #endregion Filtering
; #region Ordering
  /**
   * Reverse the direction of the sequence.
   * @template KEY, VALUE
   * @method
   * @param {object<KEY, VALUE>} source
   * @return {bee.Enumerable<KEY, VALUE>}
   */
  class reverse extends bee.rule.EnumerableFunc {
    _init() {
      this.pairs := bee.query(this.source).toArray()
      this.current := this.pairs.length
    }
    _next(&key, &value := unset) {
      if (!bee.hasKey(this.pairs, this.current)) {
        return false
      }

      pair := this.pairs[this.current]
      key := pair.key
      value := pair.value
      this.current--
      return true
    }
  }
  /**
   * Reverse the direction of the sequence.
   * @return {bee.Enumerable<KEY, VALUE>}
   */
  reverse() {
    return bee.Enumerable.reverse(this)
  }
; #endregion Ordering
; #region Converting
  /**
   * Convert to an `Array` of objects with key and value fields.
   * @template KEY, VALUE
   * @param {object<KEY, VALUE>} source
   * @return {bee.Enumerable<KEY, VALUE>}
   */
  class toArray extends bee.rule.EnumerableConverter {
    static behavior(enumerator) {
      arr := []
      for key, value in enumerator {
        arr.push({ key: key, value: value })
      }
      return arr
    }
  }
  /**
   * Convert to an `Array` of objects with key and value fields.
   * @return
   */
  toArray() {
    return bee.Enumerable.toArray(this)
  }
  /**
   * Converts `source` to an `Array` of keys.
   * @method
   * @param {bee.Enumerable}
   * @return {Array<KEY>}
   */
  class toKeys extends bee.rule.EnumerableConverter {
    static behavior(enumerator) {
      arr := []
      for key, value in enumerator {
        arr.push(key)
      }
      return arr
    }
  }
  /**
   * Converts to an `Array` of keys.
   */
  toKeys() {
    return bee.Enumerable.toKeys(this)
  }
  /**
   * Convert to `Map`.
   * @template KEY, VALUE
   * @param {object<KEY, VALUE>} source
   * @return {Map<KEY, VALUE>}
   */
  class toMap extends bee.rule.EnumerableConverter {
    static behavior(enumerator) {
      _map := Map()
      for key, value in enumerator {
        _map[key] := value
      }
      return _map
    }
  }
  /**
   * Convert to `Map`.
   * @return {Map<KEY, VALUE>}
   */
  toMap() {
    return bee.Enumerable.toMap(this)
  }
  /**
   * Convert to `Object`.
   * @param {object<KEY, VALUE>} source
   * @return {Object<KEY, VALUE>}
   */
  class toObject extends bee.rule.EnumerableConverter {
    static behavior(enumerator) {
      obj := {}
      for key, value in enumerator {
        obj.%key% := value
      }
      return obj
    }
  }
  /**
   * Convert to `Object`.
   * @return {Object<KEY, VALUE>}
   */
  toObject() {
    return bee.Enumerable.toObject(this)
  }
  /**
   * Converts `source` to an `Array` of values.
   * @method
   * @param {bee.Enumerable}
   * @return {Array<VALUE>}
   */
  class toValues extends bee.rule.EnumerableConverter {
    static behavior(enumerator) {
      arr := []
      for key, value in enumerator {
        arr.push(value)
      }
      return arr
    }
  }
  /**
   * Convert to an `Array` of values.
   */
  toValues() {
    return bee.Enumerable.toValues(this)
  }

  /**
   * `Array` and `Map` are converted to Enumerator, and the rest to improved Enumerator-like function.
   *
   * **Note that this means that using the `is` operator does not always return `true`, such as follows.*
   * @template KEY, VALUE
   * @param {object<KEY, VALUE.} source
   * @return {Enumerator | (&key: KEY, &value?: VALUE) => boolean}
   */
  static toEnumeratorLike(source) {
    if (source is Enumerator) {
      return source
    }

    if (source is bee.Enumerable) {
      if (bee.isPrimitive(source.source)) {
        return source
      }
      if (source.source is bee.Enumerable) {
        return source.source.__Enum(2)
      }
      return this.toEnumeratorLike(source.source)
    }
    if (source is Array || source is Map) {
      return source.__Enum(2)
    }
    return EnumeratorWrapper.bind(source, source.ownProps())

    EnumeratorWrapper(obj, enumerator, &key, &value) {
      hasNext := enumerator(&_key)
      if (!hasNext) {
        return false
      }
      key := _key
      value := obj.%key%
      return true
    }
  }
  /**
   * `Array` and `Map` are converted to Enumerator, and the rest to improved Enumerator-like function.
   *
   * **Note that this means that using the `is` operator does not always return `true`, such as follows.**
   * @return {Enumerator | (&key: KEY, &value?: VALUE) => boolean}
   */
  toEnumeratorLike() {
    return bee.Enumerable.toEnumeratorLike(this)
  }
; #endregion Converting
}